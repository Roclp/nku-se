# 编译原理







编译器的核心功能是把源代码翻译成目标代码



源代码

词法分析

语法分析

语义分析

中间代码生成

目标代码生成



错误处理、符号表伴随整个过程



T 有穷自动机接受的语言是正则语言。
(2) T 若 r1 和 r2 是 Σ 上的正则表达式，则 r1|r2 也是

对任何一个 NFA M，都存在一个 DFA M'，使得 L(M')=L(M)。
(5) T 对一个右线性文法 G，必存在一个左线性文法 G'，使得 L(G)=L(G')，反之亦然。

任何 LL(1)文法都是无二义性的。
(7) T 每一个 SLR(1)文法也都是 LR(1)文法。
(8) T 存在一种算法，能判定任何上下文无关文法是否是 LL(1)的。















## 语言及文法

正闭包无空串

克林闭包有空串



2型文法：上下文无关文法（CFG）



3型文法：正则





## 词法分析

### 作用

读入源程序字符流，组成词素，输出词法单元序列

过滤换行符、空白符、注释等

将词素添加到符号表中



词法单元：源代码字符集的分类

模式：如何识别字符集，分类为单词的规则（正则表达式）

词素：按模式匹配，分类为单词



### 输入缓冲

加快程序读入速度（唯一读取文件的阶段，值得优化）

#### 双缓冲区
◦ 缓冲区分成两个部分，N个字符（N = 1024 / 4096）
◦ 每次读N个字符至缓冲区，不足N个字符eof.
◦ 指针lexemeBegin：指向当前词素的开始处
◦ 指针forward：一直向前扫描直至匹配某个模式

当forward指针位于某个缓冲区末端时，装载另一个缓冲区



#### 哨兵标记

每个缓冲区末端添加标记——哨兵(sentinel): eof
减少条件判断



### 词法分析器

正则表达式r 表示语言L(r)

(a | b)\* = ( a\* b*)   表示 {e, a, b, aa, ab, ba, bb, …}



状态转换图

![image-20231224155429326](https://s2.loli.net/2023/12/24/QeGoWYbXuxjiJrk.png)

关键字的处理的两种方法

- 初始化时将各个保留字填入符号表中(查表)
- 为每个关键字建立单独的状态转换图(单独的状态转换图)

 

五元组

M = { S, Σ, δ, s0, F }，其中
1. S：有限状态集
2. Σ：有穷字母表
3. **δ：S×Σ**
4. s0∈S是唯一的初态
5. F⊆S 是一个终态集

不确定有限自动机NFA：一个状态对同一个输入符号，有多个可能的动作（简单，“不精确”，占用内存少，速度慢）

- 允许 ε (null)边
-  同一个符号可以标记从同一状态出发到多个状态的多条边

确定有限自动机DFA：一个状态对一个输入符号，至多有一个动作（没有空边，复杂，“精确”，占用内存大，速度快，适于计算机实现）

















## 语法分析

利用语法检查单词流的语法结构
• 构造语法分析树
• 语法错误和修正



上下文无关文法：四元式

四元式(VT, VN, S, P)
•VT：终结符号（单词）集，T
•VN：非终结符号（语法变量）集，NT，定义了文法/语言可生成的
符号串集合
•S：S∈NT，开始符号，定义语言的所有符号串
•P，产生式集，PR，NT(T | NT)*
规则T、NT如何组合，生成语言的合法符号串



推导（产生式）

“一步推导”
，
“直接推出”
，推导步数=1
，
“一步或多步推导”
，推导步数≥1
，
“0步或多步推导”
，推导步数≥0

句型：包含非终结符

句子：不含非终结符的句型



语法分析树：推导的图示，但不体现推导过程的顺序



一棵语法树：多个推导
一棵语法树：唯一最左推导，唯一最右推导



设计CFG

正则

NFA



修改CFG

- 二义性：句子对应多个语法树（多个最左（右）推导）
  - E+E*E(优先级)  if then else(else与最近的未匹配的then相匹配)
- 空边：
  - 利用产生式进行代入
    A  e，B  uAv  B  uv | uAv
- 回路：
  - 保证每个产生式都加入终结符（开始符号的e产生式除外)
- 左递归：（直接、间接）自顶向下分析方法无法处理，死循环 
  - A  A |         
    不以A开头，改写为：
    A  A’
    A’  A’ | e
- 左公因子：
  - 候选式公共的最长前缀



类似语言可用CFG描述













### 自顶向下分析方法：递归实现、表驱动



#### LL（1）无回溯



递归下降分析方法的缺点
不能处理左递归
复杂的回溯技术
◦回溯导致语义工作推倒重来
◦难以报告出错的确切位置
◦效率低



消除回溯（预测分析表）
产生回溯的原因
进行推导时，若产生式存在多个候选式，选择哪个候
选式进行推导存在不确定性。
消除回溯的基本原则
对文法的任何非终结符，若能根据当前读头下的符号，
准确的选择一个候选式进行推导，那么回溯就可以消除



LL(1)文法的特性
1. 无二义性，无左递归
2. 若A ，则
1) 、推导出的符号串，不能以同样的终结符a开头(多
重定义项)
2) 、至多有一个可推导出e
3) 若 e ，FIRST()∩FOLLOW(A)=F
某些语言不存在LL(1)文法，例A













### 自底向上分析方法（归约）
– LR分析方法
• LR(0) • SLR
• LR(1) • LALR



句柄（Handle）
符号串的“句柄”
◦ **与某个产生式右部匹配的子串**
◦ 归约为产生式左部最右推导逆过程
